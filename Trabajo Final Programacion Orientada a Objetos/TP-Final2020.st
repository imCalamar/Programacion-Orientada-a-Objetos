BorderedMorph subclass: #Graficadora	instanceVariableNames: 'capa1 origen colValores resultadoX inicio final graficoDePuntos miGraficador buttonClose buttonSubmit puntoX buttonSubmit2 inputFormula inputInicio inputFinal X Y formula inputX'	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Graficadora commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	botonAumX:		<Object>	botonAumY:		<Object>	botonCalcular:		<Object>	botonCerrar:		<Object>	botonDismX:		<Object>	botonDismY:		<Object>	btnaumdiv:		<Object>	btnaummax:		<Object>	btnaummin:		<Object>	btndecdiv:		<Object>	btndecmax:		<Object>	btndecmin:		<Object>	calVal:		<Object>	campo:		<Object>	grafico:		<Object>	miEcuacion:		<Object>	origen:		<Object>	txtdiv:		<Object>	txtmax:		<Object>	txtmin:		<Object>	txtvalormax:		<Object>	txtvalormin:		<Object>    Implementation Points!!Graficadora methodsFor: 'control' stamp: 'gonzalo 10/11/2020 12:37'!cerrarself delete .! !!Graficadora methodsFor: 'initialization' stamp: 'gonzalo 10/11/2020 11:58'!initialize	super initialize.	miGraficador := GraficoModelo crearGraficoModelo.	miGraficador addDependent: self.	"Para que los cambios producidos en la instancia del modelo, se reflejen en loselementos gráficos es necesario que los elementos gráficos se registren como dependientes del modelo"	colValores := OrderedCollection new.	colValores add: 0.	origen := 0.	puntoX := 's'.	inicio := 0.	final := 0.	resultadoX :='c'.	capa1 := Morph new.	graficoDePuntos := Morph new		color: Color white;		position: self center.	self dibujarFondo.	self openInWorld! !!Graficadora methodsFor: 'initialization' stamp: 'gonzalo 10/11/2020 15:32'!setParametros"guarda las variables obtenidas del morph y las guarda en las variables de instancia de la graficadora luego envia las variables graficoModelo"	inicio := inputInicio text asString.	final := inputFinal text asString.	formula := inputFormula text asString.	miGraficador obtenerResultados: formula desde: inicio hasta: final! !!Graficadora methodsFor: 'initialization' stamp: 'gonzalo 10/11/2020 15:32'!setParametroPunto	"guarda las variables obtenidas del morph y las guarda en las variables de instancia de la graficadora luego envia las variables graficoModelo"	puntoX := inputX text asString.	formula := inputFormula text asString.	miGraficador obtenerPunto: formula con: puntoX! !!Graficadora methodsFor: 'updating' stamp: 'gonzalo 10/11/2020 15:31'!update: unaCalculadora"este metodo nos permite actualizar el morph para poder utilizarlo nuevamente"	resultadoX := unaCalculadora getResultadoX.	resultadoX isNumber | resultadoX isFloat		ifTrue: [ self dibujarPunto.			unaCalculadora resetearX ]		ifFalse: [ colValores := unaCalculadora getColValores.			self dibujarPuntos ]! !!Graficadora methodsFor: 'dibujarMorph' stamp: 'gonzalo 10/12/2020 16:51'!dibujarFondo	| capa2 ejeX ejeY |	capa1 := Morph new color: Color darkGray.	capa1 height: 700.	capa1 width: 600.	capa2 := Morph new color: Color white.	capa2 height: 520.	capa2 width: 520.	ejeX := Morph new color: Color red.	ejeY := Morph new color: Color red.	ejeX width: 520.	ejeX height: 4.	ejeY width: 4.	ejeY height: 520.	"lo que creamos el fondo gris que es la capa 1 donde estara sujeta la capa2 los campos a rellenar y los botones, y tambien diseñamos la capa2 y los ejes"	self addMorph: capa1.	capa1 addMorph: capa2.	capa2 addMorph: ejeX.	capa2 addMorph: ejeY.	"con addMorph aderimos Morphs a otros"	capa2 center: capa1 center + (-20 @ -60).	ejeX center: capa2 center + (0 @ 260).	ejeY center: capa2 center + (-260 @ 0).	"aca implementamos los botones"	inputFormula := TextMorph new		contents: 'escriba la ecuacion';		position: 10 @ 560;		color: Color black;		backgroundColor: Color white.	inputX := TextMorph new		contents: 'ingrese x';		position: 10 @ 590;		color: Color black;		backgroundColor: Color white.	X := TextMorph new		contents: 'X';		position: 545 @ 540;		color: Color red;		backgroundColor: Color darkGray.	Y := TextMorph new		contents: 'Y';		position: 15 @ 8;		color: Color red;		backgroundColor: Color darkGray.	inputInicio := TextMorph new		contents: 'escriba el comienzo del intervalo';		position: 10 @ 620;		color: Color black;		backgroundColor: Color white.	inputFinal := TextMorph new		contents: 'escriba el final del intervalo';		position: 10 @ 650;		color: Color black;		backgroundColor: Color white.	capa1 addMorph: X.	capa1 addMorph: Y.	capa1 addMorph: inputFormula.	capa1 addMorph: inputFinal.	capa1 addMorph: inputInicio.	capa1 addMorph: inputX.	buttonSubmit := SimpleButtonMorph new		position: 200 @ 560;		target: self;		actionSelector: #setParametros;		label: 'Graficar intervalo';		color: Color black;		yourself.	buttonSubmit2 := SimpleButtonMorph new		position: 400 @ 560;		target: self;		actionSelector: #setParametroPunto;		label: 'Graficar punto';		color: Color black;		yourself.	capa1 addMorph: buttonSubmit.	capa1 addMorph: buttonSubmit2.	buttonClose := SimpleButtonMorph new		position: 580 @ 0;		target: self;		actionSelector: #cerrar;		label: 'X';		color: Color red;		yourself.	capa1 addMorph: buttonClose.	origen := capa2 innerBounds origin! !!Graficadora methodsFor: 'dibujarMorph' stamp: 'gonzalo 10/11/2020 16:08'!dibujarPuntos	| puntos i ancho topeEjeY altura posicion |	posicion := capa1 position + (22 @ 550).	"esta es la posicion de la imagen de smallatalk no de la graficadora"	graficoDePuntos delete.	"cada vez que se carga un grafico nuevo este limpia los puntos del grafico anterior"	graficoDePuntos := Morph new		color: (Color black alpha: 0.0);		position: posicion + (70 @ 550).	ancho := 520 / colValores size.	"ancho del fondo blanco de mi graficador"	colValores max - colValores min ~= 0		ifTrue: [ topeEjeY := colValores max - colValores min ]		ifFalse: [ topeEjeY := 1 ].	i := 1.	[ i <= colValores size ]		whileTrue:			[ altura := ((colValores at: i) + (-1 * colValores min)) * 520 / topeEjeY * -1.	"el menos uno es para que no se invierta el grafico"			puntos := (((CircleMorph new color: Color lightCyan) height: 8) width: 8)				center: posicion + (((i - 1) * ancho) @ altura).			i := i + 1.			graficoDePuntos addMorph: puntos ].	capa1 addMorph: graficoDePuntos! !!Graficadora methodsFor: 'dibujarMorph' stamp: 'gonzalo 10/12/2020 16:52'!dibujarPunto	| puntoAux posicion |	posicion := capa1 position + (22 @ 550).	"esta es la posicion de la imagen de smalltalk no de la graficadora"	graficoDePuntos delete.	"cada vez que se carga un grafico nuevo este limpia los puntos del grafico anterior"	graficoDePuntos := Morph new		color: (Color black alpha: 0.0);		position: posicion + (70 @ 550).	puntoAux := (((CircleMorph new color: Color lightCyan) height: 8) width: 8)		center: posicion + (puntoX asNumber @ (-1 * resultadoX asNumber)).	"al igual que en dibujarPuntos esto lo que hace es diseñar la forma, color y tamaño de o de los puntos dependiendo del metodo utilizado"	graficoDePuntos addMorph: puntoAux.	capa1 addMorph: graficoDePuntos! !Object subclass: #GraficoModelo	instanceVariableNames: 'funcion parser colRes cadena inicio final variableX resultadoX'	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!GraficoModelo commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	divisiones:		<Object>	funcion:		<Object>	parser:		<Object>    Implementation Points!!GraficoModelo methodsFor: 'get' stamp: 'gonzalo 10/10/2020 18:42'!getColValores^colRes .! !!GraficoModelo methodsFor: 'get' stamp: 'gonzalo 10/11/2020 11:55'!getResultadoX^resultadoX .! !!GraficoModelo methodsFor: 'aplicacion' stamp: 'gonzalo 10/11/2020 15:27'!resolver	| i res |	"este while que crea una coleccion de resultados"	funcion := parser armarArbol: cadena.	colRes := OrderedCollection new.	i := inicio.	[ i <= (final + 0.1) ]"el avance de 0.1 es para poder graficar varios puntos a numero mayor menos puntos se graficarian (guardarian en la coleccion)"		whileTrue: [ res := funcion evaluar: i.			colRes add: res.			i := i + 0.1 ].	self changed! !!GraficoModelo methodsFor: 'aplicacion' stamp: 'gonzalo 10/11/2020 15:29'!obtenerResultados: unaFormula desde: unInicio hasta: unFinal"recibe las variables de la clase graficadora y las almacena en las variables de instancia de grafico modelo"	inicio := unInicio asNumber.	final := unFinal asNumber.	cadena := unaFormula.	self resolver! !!GraficoModelo methodsFor: 'aplicacion' stamp: 'gonzalo 10/11/2020 15:24'!resolverPunto"este metodo toma la cadena llama al metodo de armar arbol para poder convertirlo en coleccion y luego junto con el valor a reemplazar lo trabaja en el metodo evaluar"	funcion := parser armarArbol: cadena.	resultadoX := funcion evaluar: variableX.	self changed! !!GraficoModelo methodsFor: 'aplicacion' stamp: 'gonzalo 10/11/2020 15:29'!obtenerPunto: unaFormula con: unPunto"recibe las variables de la clase graficadora y las almacena en las variables de instancia de grafico modelo"	variableX := unPunto asNumber.	cadena := unaFormula.	self resolverPunto! !!GraficoModelo methodsFor: 'aplicacion' stamp: 'gonzalo 10/11/2020 15:28'!resetearX "este metodo nos permite utilizar el graficar entre intervalos despues de haber graficado un solo punto"	resultadoX := 's'! !!GraficoModelo methodsFor: 'inicializador' stamp: 'gonzalo 10/11/2020 11:56'!inicializarGraficoModelo	parser := ParserTPFinal crearParser.	colRes := OrderedCollection new.	cadena := ''.	inicio := 0.	final := 0.	variableX := 's'.	resultadoX :='c'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GraficoModelo class	instanceVariableNames: ''!!GraficoModelo class methodsFor: 'constructor' stamp: 'gonzalo 10/1/2020 08:40'!crearGraficoModelo|nuevoGraficoModelo|nuevoGraficoModelo := self new.nuevoGraficoModelo  inicializarGraficoModelo .^nuevoGraficoModelo .! !Object subclass: #ParserTPFinal	instanceVariableNames: 'cadena arreglo'	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!ParserTPFinal commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	arreglo:		<Object>	cadena:		<Object>    Implementation Points!!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 16:56'!agregarDigito: unNumero de: unaCadena en: i	| respuesta |	respuesta := unNumero , (unaCadena copyFrom: i to: i).	"si unNumero no es vacio, aca simplemente concatenamos ya sea la coma decimal o el numero que se encuentra en la cadena unaCadenaen la posicion i"	^ respuesta! !!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 16:59'!este: unSimboloEnPila MayorQue: unSimboloEnCola	| auxBooleano i res |	i := 1.	auxBooleano := true.	res := false.	unSimboloEnPila = $(		ifFalse: [ "si el simbolo que se encuentra en la pila no es un parentesis	 que abre entra a preguntar sobre la jerarquia de los simbolos"			[ i <= 10 and: auxBooleano ]				whileTrue: [ "este whileTrue va a recorrer el arreglo de jerarquia hasta que se encuentre 	el simbolo de la pila o de la cola en primer lugar"					(arreglo at: i) = unSimboloEnPila						ifTrue: [ "si esta if se cumple significa que aparecio primer el simbolo de la pila		por lo tanto tiene menor jerarquia que el de la cola"							res := false.							auxBooleano := false ]						ifFalse: [ (arreglo at: i) = unSimboloEnCola								ifTrue: [ "si este if se cumple significa que aparecio primer el simbolo de la cola		por lo tanto tiene menor jerarquia que el de la pila"									res := true.									auxBooleano := false ]								ifFalse: [ i := i + 1 ] ] ] ].	^ res! !!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 16:58'!armarTipoUnario: unOperador conTermino1: aux1	| nuevoNodoUnario |	"este metodo se encarga de revisar que tipo de operador va a trabajar y crear un objeto de tipo binario del tipo de operador que llama"	unOperador = 'tan'		ifTrue: [ nuevoNodoUnario := Tangente crearUnario: aux1 ]		ifFalse: [ unOperador = 'sen'				ifTrue: [ nuevoNodoUnario := Seno crearUnario: aux1 ]				ifFalse: [ unOperador = $!!						ifTrue: [ nuevoNodoUnario := Factorial crearUnario: aux1 ]						ifFalse: [ unOperador = 'sqrt'								ifTrue: [ nuevoNodoUnario := RaizCuadrada crearUnario: aux1 ]								ifFalse: [ nuevoNodoUnario := Coseno crearUnario: aux1 ] ] ] ].	^ nuevoNodoUnario! !!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 16:58'!armarArbol: unaCadena	| nodo colSimbolos pila longitud i aux1 aux2 numero |	i := 1.	pila := Stack new.	colSimbolos := self parsear: unaCadena.	"este metodo nos va a devolver una coleccion de simbolos ordenados"	longitud := colSimbolos size.	[ i <= longitud ]		whileTrue: [ (colSimbolos at: i) isNumber				ifTrue: [ numero := Numero crearUnario: (colSimbolos at: i).	"si es un numero se guarda en la pila como valor de tipo numero"					pila push: numero.					i := i + 1 ]				ifFalse: [ "recorrido de la coleccion de simbolos de inicio a fin"					(colSimbolos at: i) = $x						ifTrue: [ numero := Numero crearUnario: (colSimbolos at: i).							pila push: numero.							i := i + 1 ]						ifFalse: [ "si detecta la variable x la guarda en la pila"							(colSimbolos at: i) = $+ | ((colSimbolos at: i) = $-) | ((colSimbolos at: i) = $*) | ((colSimbolos at: i) = $/)								| ((colSimbolos at: i) = $^)								ifTrue: [ "aca se resuelve para casos binarios"									"primero ponemos el tope de la pila en aux2 porque si por 				ejemplo tuvieramos una expresion 5-9 primero coloca 5 en pila y luego 9				pero al vaciar la pila 9 tiene que estar en aux2 sino resolveria mal la resta y daria positivo"									aux2 := pila pop.									aux1 := pila pop.									nodo := self armarTipobinario: (colSimbolos at: i) conTermino1: aux1 conTermino2: aux2.									pila push: nodo.									i := i + 1 ]								ifFalse: [ "casos unarios"									"si es alguno de estos operadores lo que hace es desapila			dos elementos de la pila y crea el nodo que contiene a la operacion del operador que fue detectado"									aux1 := pila pop.									nodo := self armarTipoUnario: (colSimbolos at: i) conTermino1: aux1.									pila push: nodo.									i := i + 1 ] ] ] ].	^ pila top	"retorna la raiz del arbol que es la que contiene todo el arbol"	"en este metodo/clase generamos nodos formando un arbol donde separamos los terminos de los operadores y se almacena todo en una pila, al final del recorrido de la colección de simbolos queda guardado en el tope de la pila el nodo que contiene a todas las operaciones desde la raiz"! !!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 16:58'!armarTipobinario: unOperador conTermino1: aux1 conTermino2: aux2	| nuevoNodoBinario |	"este metodo se encarga de revisar que tipo de operador va a trabajar y crear un objeto de tipo binario del tipo de operador que llama"	unOperador = $+		ifTrue: [ nuevoNodoBinario := Suma crearBinario: aux1 y: aux2 ]		ifFalse: [ unOperador = $-				ifTrue: [ nuevoNodoBinario := Resta crearBinario: aux1 y: aux2 ]				ifFalse: [ unOperador = $/						ifTrue: [ nuevoNodoBinario := Division crearBinario: aux1 y: aux2 ]						ifFalse: [ unOperador = $*								ifTrue: [ nuevoNodoBinario := Multiplicacion crearBinario: aux1 y: aux2 ]								ifFalse: [ nuevoNodoBinario := Potencia crearBinario: aux1 y: aux2 ] ] ] ].	^ nuevoNodoBinario! !!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 17:00'!parsear: unaCadena	| longitud i pila cola colValores |	colValores := self separarPorSimbolos: unaCadena.	i := 1.	pila := Stack new.	cola := LinkedList new.	longitud := colValores size.	[ i <= longitud ]		whileTrue: [ (colValores at: i) isNumber				ifTrue: [ cola addLast: (colValores at: i).					i := i + 1 ]				ifFalse: [ (colValores at: i) = $(						ifTrue: [ pila push: (colValores at: i).							i := i + 1 ]						ifFalse: [ (colValores at: i) = $)								ifTrue: [ [ pila top = $( ] whileFalse: [ cola addLast: pila pop ].									"con el whilFalse quitamos todo el contenido que se encuentra dentro de los parentesis dentro de la pila					fuera del whileFalse quitamos un elemento mas de la pila que es el parentesis que cierra"									i := i + 1.									pila pop ]								ifFalse: [ pila isEmpty										ifTrue: [ pila push: (colValores at: i).											i := i + 1 ]										ifFalse: [ (self este: pila top MayorQue: (colValores at: i))												ifTrue: [ cola addLast: pila pop.													pila push: (colValores at: i).													i := i + 1 ]												ifFalse: [ pila push: (colValores at: i).													i := i + 1 ] ] ] ] ] ].	[ pila isEmpty ] whileFalse: [ cola addLast: pila pop ].	cola do: [ :value |  ].	"en este ultimo while se encarga de vaciar lo que pueda llegar a haber quedadon en la pila"	^ cola! !!ParserTPFinal methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 17:00'!separarPorSimbolos: unaCadena	| colSimbolos i numero longitud |	"metodo encargado de crear una coleccion de simbolos y numeros separados entre si"	cadena := unaCadena.	longitud := unaCadena size.	colSimbolos := OrderedCollection new.	numero := ''.	i := 1.	[ i <= longitud ]		whileTrue: [ ((cadena at: i) isDigit or: (cadena at: i) asUnicode = 46)				ifTrue: [ "unicode en 46 el la coma decimal"					"en este paso guardamos dentro del string 'numero' numeros enteros o reales"					numero := self agregarDigito: numero de: cadena en: i.					i := i + 1 ]				ifFalse: [ (cadena at: i) asUnicode = 115						ifTrue: [ "en unicode el valor 115 es la letra s minuscula"							i := i + 1.							(cadena at: i) asUnicode = 113								ifTrue: [ "en unicode el 113 es la letra minuscula q"									colSimbolos add: 'sqrt'.									i := i + 3 ]								ifFalse: [ colSimbolos add: 'sen'.									i := i + 2 ] ].					(cadena at: i) asUnicode = 99						ifTrue: [ "en unicode el valor 99 es la letra minuscula c"							colSimbolos add: 'cos'.							i := i + 3 ].					(cadena at: i) asUnicode = 116						ifTrue: [ "en unicode el valor 116 es la letra minuscula t"							colSimbolos add: 'tan'.							i := i + 3 ].					numero = ''						ifFalse: [ "aca entra cuando numero NO esta vacio"							colSimbolos add: numero asNumber.							numero := ''.							colSimbolos add: (cadena at: i).							i := i + 1 ]						ifTrue: [ "aca entra cuando numero esta vacio"							colSimbolos add: (cadena at: i).							i := i + 1 ] ] ].	((cadena at: i - 1) isDigit or: (cadena at: i - 1) asUnicode = 46)		ifTrue: [ "46 es punto decimal" colSimbolos add: numero asNumber ].	^ colSimbolos! !!ParserTPFinal methodsFor: 'inicializador' stamp: 'gonzalo 9/29/2020 11:41'!inicializarParserarreglo:=Array new:10. "array de tamaño 10  esto de aca es el arreglo"arreglo at:1 put:$-.arreglo at:2 put:$+.arreglo at:3 put:$/.arreglo at:4 put:$*.arreglo at:5 put:$^.arreglo at:6 put:'sen'.arreglo at:7 put:'cos'.arreglo at:8 put:'tan'.arreglo at:9 put:$!!.arreglo at:10 put:'sqrt'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParserTPFinal class	instanceVariableNames: ''!!ParserTPFinal class methodsFor: 'constructor' stamp: 'gonzalo 9/29/2020 11:41'!crearParser |nuevoParser |	nuevoParser :=self new .	nuevoParser inicializarParser.	^nuevoParser.! !Object subclass: #Termino	instanceVariableNames: 'termino1 expresion pila'	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Termino commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	termino1:		<Object>    Implementation Points!!Termino methodsFor: 'inicializador' stamp: 'gonzalo 10/12/2020 15:15'!iniciarTermino: unaCadena	expresion := unaCadena.	pila := OrderedCollection new.	! !!Termino methodsFor: 'aplicacion' stamp: 'gonzalo 9/29/2020 12:39'!evaluar:unValor^self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Termino class	instanceVariableNames: ''!!Termino class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:21'!crearTermino:unaCadena |nuevoTermino|nuevoTermino :=self new.nuevoTermino iniciarTermino: unaCadena .^nuevoTermino .! !Termino subclass: #Binario	instanceVariableNames: 'termino2'	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Binario commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	termino2:		<Object>    Implementation Points!!Binario methodsFor: 'aplicacion' stamp: 'gonzalo 9/28/2020 19:44'!evaluar:unValor^self subclassResponsibility.! !!Binario methodsFor: 'inicializador' stamp: 'gonzalo 9/21/2020 11:26'!inicializarBinarioCon:unTermino1 y:unTermino2termino1 :=unTermino1 .termino2 :=unTermino2 .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binario class	instanceVariableNames: ''!!Binario class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:28'!crearBinario:unTermino1 y:unTermino2|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarBinarioCon: unTermino1  y:unTermino2 .^nuevoTermino . ! !Binario subclass: #Division	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Division commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Division methodsFor: 'aplicacion' stamp: 'gonzalo 10/12/2020 17:01'!evaluar: unValor	(termino1 evaluar: unValor) \\ (termino2 evaluar: unValor) = 0		ifTrue:			[ "preguntamos si el resto de dividir el temrino1 con el termino2 es cero, en el caso de que sea true va a " "devolver un numero entero si es false devuelve un numero con coma" ^ (termino1 evaluar: unValor) / (termino2 evaluar: unValor) ]		ifFalse: [ ^ ((termino1 evaluar: unValor) / (termino2 evaluar: unValor)) asFloat ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Division class	instanceVariableNames: ''!!Division class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:32'!crearBinario:unTermino1 y:unTermino2|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarBinarioCon: unTermino1  y:unTermino2 .^nuevoTermino . ! !Binario subclass: #Multiplicacion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Multiplicacion commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Multiplicacion methodsFor: 'aplicacion' stamp: 'gonzalo 9/28/2020 19:54'!evaluar:unValor^((termino1 evaluar:unValor)*(termino2 evaluar: unValor )).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Multiplicacion class	instanceVariableNames: ''!!Multiplicacion class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:33'!crearBinario:unTermino1 y:unTermino2|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarBinarioCon: unTermino1  y:unTermino2 .^nuevoTermino . ! !Binario subclass: #Potencia	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Potencia commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Potencia methodsFor: 'aplicacion' stamp: 'gonzalo 9/28/2020 19:54'!evaluar:unValor^((termino1 evaluar:unValor)raisedTo: (termino2 evaluar: unValor )).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Potencia class	instanceVariableNames: ''!!Potencia class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:33'!crearBinario:unTermino1 y:unTermino2|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarBinarioCon: unTermino1  y:unTermino2 .^nuevoTermino . ! !Binario subclass: #Resta	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Resta commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Resta methodsFor: 'aplicacion' stamp: 'gonzalo 9/28/2020 19:55'!evaluar:unValor^((termino1 evaluar:unValor)-(termino2 evaluar: unValor )).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Resta class	instanceVariableNames: ''!!Resta class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:34'!crearBinario:unTermino1 y:unTermino2|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarBinarioCon: unTermino1  y:unTermino2 .^nuevoTermino . ! !Binario subclass: #Suma	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Suma commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Suma methodsFor: 'aplicacion' stamp: 'gonzalo 10/5/2020 19:12'!evaluar:unValor^((termino1 evaluar:unValor)+(termino2 evaluar: unValor )).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Suma class	instanceVariableNames: ''!!Suma class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:34'!crearBinario:unTermino1 y:unTermino2|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarBinarioCon: unTermino1  y:unTermino2 .^nuevoTermino . ! !Termino subclass: #Unario	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Unario commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Unario methodsFor: 'inicializador' stamp: 'gonzalo 10/5/2020 17:44'!inicializarUnario:unTerminotermino1 :=unTermino .! !!Unario methodsFor: 'aplicacion' stamp: 'gonzalo 9/28/2020 19:44'!evaluar:unValor^self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unario class	instanceVariableNames: ''!!Unario class methodsFor: 'constructor' stamp: 'gonzalo 10/5/2020 11:22'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^(nuevoTermino) .! !Unario subclass: #Coseno	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Coseno commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Coseno methodsFor: 'aplicacion' stamp: 'gonzalo 10/5/2020 00:00'!evaluar: unValor    | res |res := ((termino1  evaluar: unValor) cos).^ res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Coseno class	instanceVariableNames: ''!!Coseno class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:40'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^nuevoTermino .! !Unario subclass: #Factorial	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Factorial commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Factorial methodsFor: 'aplicacion' stamp: 'gonzalo 10/5/2020 00:00'!evaluar: unValor    |res|res := ((termino1 evaluar: (unValor)) factorial).^res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Factorial class	instanceVariableNames: ''!!Factorial class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:42'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^nuevoTermino .! !Unario subclass: #Numero	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Numero commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Numero methodsFor: 'aplicacion' stamp: 'gonzalo 10/7/2020 21:50'!evaluar: unValor    termino1  = $x        ifTrue: [ 	^ (unValor asNumber ). 	]ifFalse: [	     ^ (termino1 asNumber ).	  ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Numero class	instanceVariableNames: ''!!Numero class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:43'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^nuevoTermino .! !Unario subclass: #RaizCuadrada	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!RaizCuadrada commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!RaizCuadrada methodsFor: 'aplicacion' stamp: 'gonzalo 10/5/2020 00:00'!evaluar: unValor|res|res := ((termino1  evaluar: unValor) sqrt).^res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RaizCuadrada class	instanceVariableNames: ''!!RaizCuadrada class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:43'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^nuevoTermino .! !Unario subclass: #Seno	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Seno commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Seno methodsFor: 'aplicacion' stamp: 'gonzalo 10/4/2020 23:59'!evaluar: unValor    | res |res := ((termino1 evaluar: unValor) sin).^res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Seno class	instanceVariableNames: ''!!Seno class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:42'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^nuevoTermino .! !Unario subclass: #Tangente	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TP-Final2020'!!Tangente commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Tangente methodsFor: 'aplicacion' stamp: 'gonzalo 10/4/2020 23:59'!evaluar: unValor    | res |    res := ((termino1  evaluar: unValor) sin / (termino1  evaluar: unValor) cos)."esto lo resolvimos asi porque el tangente de smalltalk no devuelve el mismo resultado que esto"    ^ res! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Tangente class	instanceVariableNames: ''!!Tangente class methodsFor: 'constructor' stamp: 'gonzalo 9/21/2020 11:43'!crearUnario:unTermino|nuevoTermino|nuevoTermino :=self new.nuevoTermino inicializarUnario: unTermino .^nuevoTermino .! !